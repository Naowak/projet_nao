<html>
    <head><script src="easeljs.min.js"></script></head>
    <body onload="init();" style="margin:0;"></body>
        <canvas id="canvas"></canvas>
    </body>

    <script>
        var screen = {width: 0,
                      height: 0,
                      margin: 5,
                      inner_width: 0,
                      inner_height: 0,
                      top: 0,
                      left: 0,
                      bottom: 0,
                      right: 0};

        var sidebar = {width: 0,
                       columns: 6,
                       right: 0,
                       choices: {lines: 10,
                                 height: 0,
                                 left: 0,
                                 bottom: 0},
                       }

        var grid = {columns: 10,
                    lines: 18,
                    block_size: 0,
                    width: 0,
                    height: 0,
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0,
                    holding_lines: 4};

        var game = {score: 1000};

        var piece_T = [[-1,0],[0,0],[0,1],[1,0]];
        var piece_I = [[-1.5,-0.5],[-0.5,-0.5],[0.5,-0.5],[1.5,-0.5]];

        function init() {
            var canvas = document.getElementById("canvas");

            stage = new createjs.Stage("canvas");

            function resize() {
                screen.height = window.innerHeight;
                canvas.height = screen.height;
                screen.top = screen.margin;
                screen.inner_height = screen.height - 2*screen.top;

                grid.height = screen.inner_height;
                grid.block_size = grid.height / grid.lines;
                grid.width = grid.block_size * grid.columns;

                sidebar.width = sidebar.columns * grid.block_size;

                screen.width = sidebar.width + grid.width + 2*screen.margin;
                canvas.width = screen.width;
                screen.left = screen.margin;
                screen.inner_width = screen.width - 2*screen.margin;
                screen.right = screen.left + screen.inner_width;
                screen.bottom = screen.top + screen.inner_height;

                grid.left = screen.right - grid.width;
                grid.top = screen.top;
                grid.right = screen.right;
                grid.bottom = screen.bottom;

                sidebar.choices.height = sidebar.choices.lines * grid.block_size;
                sidebar.right = grid.left;
                sidebar.choices.bottom = screen.bottom - grid.block_size;
                sidebar.choices.left = screen.left + 2*grid.block_size;
            }
            resize();
            //window.addEventListener("resize", resize, false);

            root = new createjs.Container();
            stage.addChild(root);

            drawBackground();
            update();
        }

        function update() {
            stage.update();
        }

        function drawBackground() {
            var boundary = new createjs.Shape();
            boundary.graphics
                     .setStrokeStyle(1)
                     .beginStroke("black")
                     .drawRect(screen.left, screen.top, screen.inner_width, screen.inner_height)
                     .moveTo(grid.left, grid.top)
                     .lineTo(grid.left, grid.bottom);
            root.addChild(boundary);

            var grid_lines = new createjs.Shape();
            grid_lines.graphics
                .setStrokeStyle(1)
                .beginStroke("grey");
            for(var i=1; i<grid.columns; i++) {
                grid_lines.graphics.setStrokeDash([])
                    .moveTo(grid.left+grid.block_size*i, grid.top+grid.holding_lines*grid.block_size)
                    .lineTo(grid.left+grid.block_size*i, grid.bottom);
                grid_lines.graphics.setStrokeDash([5,5])
                    .moveTo(grid.left+grid.block_size*i, grid.top)
                    .lineTo(grid.left+grid.block_size*i, grid.top+grid.holding_lines*grid.block_size);
            }
            for(var i=1; i<grid.lines; i++) {
                if(i < grid.holding_lines)
                    grid_lines.graphics.setStrokeDash([5,5]);
                else
                    grid_lines.graphics.setStrokeDash([]);
                grid_lines.graphics
                    .moveTo(grid.left, grid.top+grid.block_size*i)
                    .lineTo(grid.right, grid.top+grid.block_size*i);
            }

            root.addChild(grid_lines);

            var choices_box = new createjs.Shape();
            choices_box.graphics
                .setStrokeStyle(1)
                .beginStroke("grey")
                .moveTo(screen.left, screen.bottom - sidebar.choices.height)
                .lineTo(sidebar.right, screen.bottom - sidebar.choices.height);

            root.addChild(choices_box);
        }

        function drawInfo() {
            var score = new createjs.Text("Score : "+game.score, "20px Arial", "black");
            score.x = screen.left + 20;
            score.y = screen.top + 20;

            root.addChild(score);
            update();
        }

        function drawChoices(choices) {
            var place = sidebar.choices;
            //place.bottom -= grid.block_size;
            place.left += grid.block_size*0.5;
            choices.forEach((e,i) => {
                drawPiece(e.blocks, e.color, [0,0], place);
                place.bottom -= 3*grid.block_size;
            });

            update();
        }

        function drawBlock(color, pos, ref=grid) {
            var block = new createjs.Shape();
            var [x, y] = pos;
            var left = ref.left + x*grid.block_size;
            var top = ref.bottom - (y+1)*grid.block_size;
            block.graphics
                 .beginFill(color)
                 .drawRect(left, top, grid.block_size, grid.block_size)
                 .endFill().beginStroke("black")
                 .drawRect(left, top, grid.block_size, grid.block_size);

            root.addChild(block);
        }

        function drawPiece(blocks, color, pos, ref=grid) {
            [center_x, center_y] = pos;
            blocks = blocks.map(([x,y]) => [center_x+x,center_y+y]);
            blocks.forEach((e,i) => {drawBlock(color, e, ref)});
            update();
        }
      </script>
</html>
